"""
Data types for the IB Breakout Optimizer.

Defines core dataclasses for bars, sessions, trades, and signals.
"""

from dataclasses import dataclass, field
from datetime import datetime, date, time
from enum import Enum
from typing import Optional, List, Dict
import pandas as pd


class TradeDirection(Enum):
    """Direction of a trade."""
    LONG = "long"
    SHORT = "short"
    BOTH = "both"


class StopLossType(Enum):
    """Type of stop loss calculation."""
    OPPOSITE_IB = "opposite_ib"
    MATCH_TARGET = "match_target"
    ATR = "atr"
    PERCENT = "percent"


class TargetMode(Enum):
    """Method for calculating profit target."""
    PERCENT = "percent"
    IB_MULTIPLE = "ib_multiple"
    ATR = "atr"


class OrderType(Enum):
    """Type of order."""
    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"
    STOP_LIMIT = "stop_limit"


class OrderSide(Enum):
    """Side of an order."""
    BUY = "buy"
    SELL = "sell"


class PositionStatus(Enum):
    """Status of a position."""
    FLAT = "flat"
    LONG = "long"
    SHORT = "short"


class SignalType(Enum):
    """Type of trading signal."""
    LONG_ENTRY = "long_entry"
    SHORT_ENTRY = "short_entry"
    EXIT = "exit"


class ExitReason(Enum):
    """Reason for exiting a trade."""
    PROFIT_TARGET = "profit_target"
    STOP_LOSS = "stop_loss"
    TRAILING_STOP = "trailing_stop"
    BREAK_EVEN_STOP = "break_even_stop"
    MAX_BARS = "max_bars"
    EOD_EXIT = "eod_exit"
    SIGNAL = "signal"


@dataclass
class Bar:
    """
    Single OHLCV bar.

    Attributes:
        timestamp: Bar timestamp (start of bar for NinjaTrader)
        open: Opening price
        high: Highest price
        low: Lowest price
        close: Closing price
        volume: Trading volume
        ticker: Instrument symbol
    """
    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: int
    ticker: str = ""

    @property
    def date(self) -> date:
        """Get the date component."""
        return self.timestamp.date()

    @property
    def time(self) -> time:
        """Get the time component."""
        return self.timestamp.time()

    def __repr__(self) -> str:
        return f"Bar({self.ticker} {self.timestamp} O:{self.open:.2f} H:{self.high:.2f} L:{self.low:.2f} C:{self.close:.2f} V:{self.volume})"


@dataclass
class InitialBalance:
    """
    Initial Balance (IB) levels for a trading session.

    The IB is the price range established during the first N minutes
    of a trading session (typically 30 minutes).

    Attributes:
        date: Trading date
        ticker: Instrument symbol
        session_start: Session start time
        ib_end_time: End of IB period
        ib_high: Highest price during IB
        ib_low: Lowest price during IB
        ib_range: IB range (high - low)
        ib_range_pct: IB range as percentage of IB low
        is_calculated: Whether IB has been finalized
    """
    date: date
    ticker: str
    session_start: datetime
    ib_end_time: datetime
    ib_high: float = 0.0
    ib_low: float = float('inf')
    ib_range: float = 0.0
    ib_range_pct: float = 0.0
    is_calculated: bool = False

    def update(self, bar: Bar) -> None:
        """Update IB levels with a new bar during IB period."""
        if not self.is_calculated:
            if bar.high > self.ib_high:
                self.ib_high = bar.high
            if bar.low < self.ib_low:
                self.ib_low = bar.low
            self._calculate_range()

    def finalize(self) -> None:
        """Lock in the IB levels after IB period ends."""
        self._calculate_range()
        self.is_calculated = True

    def _calculate_range(self) -> None:
        """Calculate IB range and percentage."""
        if self.ib_low > 0 and self.ib_low < float('inf'):
            self.ib_range = self.ib_high - self.ib_low
            self.ib_range_pct = (self.ib_range / self.ib_low) * 100

    def __repr__(self) -> str:
        return f"IB({self.ticker} {self.date} H:{self.ib_high:.2f} L:{self.ib_low:.2f} Range:{self.ib_range_pct:.2f}%)"


@dataclass
class Signal:
    """
    Trading signal generated by the strategy.

    Attributes:
        timestamp: When signal was generated
        ticker: Instrument symbol
        signal_type: Type of signal (long/short entry, exit)
        price: Price at signal generation
        ib: Initial Balance levels at signal time
        reason: Why the signal was generated
    """
    timestamp: datetime
    ticker: str
    signal_type: SignalType
    price: float
    ib: Optional[InitialBalance] = None
    reason: str = ""

    def __repr__(self) -> str:
        return f"Signal({self.ticker} {self.signal_type.value} @ {self.price:.2f} {self.timestamp})"


@dataclass
class Order:
    """
    Order to be submitted to the market.

    Attributes:
        order_id: Unique order identifier
        timestamp: Order creation time
        ticker: Instrument symbol
        order_type: Market, limit, stop, etc.
        side: Buy or sell
        quantity: Number of shares
        price: Limit/stop price (None for market)
        signal_name: Name of the signal that generated this order
    """
    order_id: str
    timestamp: datetime
    ticker: str
    order_type: OrderType
    side: OrderSide
    quantity: int
    price: Optional[float] = None
    signal_name: str = ""

    def __repr__(self) -> str:
        price_str = f"@ {self.price:.2f}" if self.price else "MKT"
        return f"Order({self.order_id} {self.side.value} {self.quantity} {self.ticker} {self.order_type.value} {price_str})"


@dataclass
class Fill:
    """
    Execution fill for an order.

    Attributes:
        fill_id: Unique fill identifier
        order_id: Related order ID
        timestamp: Fill time
        ticker: Instrument symbol
        side: Buy or sell
        quantity: Filled quantity
        price: Fill price
        commission: Commission charged
        slippage: Slippage incurred
    """
    fill_id: str
    order_id: str
    timestamp: datetime
    ticker: str
    side: OrderSide
    quantity: int
    price: float
    commission: float = 0.0
    slippage: float = 0.0

    def __repr__(self) -> str:
        return f"Fill({self.fill_id} {self.side.value} {self.quantity} {self.ticker} @ {self.price:.2f})"


@dataclass
class Trade:
    """
    Completed round-trip trade.

    Attributes:
        trade_id: Unique trade identifier
        ticker: Instrument symbol
        direction: Long or short
        entry_time: Entry timestamp
        entry_price: Entry fill price
        exit_time: Exit timestamp
        exit_price: Exit fill price
        quantity: Position size
        pnl: Profit/loss (gross)
        pnl_pct: P&L as percentage of entry
        commission: Total commission
        exit_reason: Why the trade was exited
        ib: Initial Balance at entry
        mae: Maximum Adverse Excursion (worst drawdown during trade)
        mfe: Maximum Favorable Excursion (best profit during trade)
        bars_held: Number of bars position was held
        move_capture_pct: Percentage of available move captured (Krafer-style metric)
    """
    trade_id: str
    ticker: str
    direction: TradeDirection
    entry_time: datetime
    entry_price: float
    exit_time: Optional[datetime] = None
    exit_price: Optional[float] = None
    quantity: int = 0
    pnl: float = 0.0
    pnl_pct: float = 0.0
    commission: float = 0.0
    exit_reason: Optional[ExitReason] = None
    ib: Optional[InitialBalance] = None
    mae: float = 0.0
    mfe: float = 0.0
    bars_held: int = 0
    move_capture_pct: float = 0.0  # % of available move captured (exit-entry)/(day_high-ib_level)

    def calculate_pnl(self) -> None:
        """Calculate P&L after exit."""
        if self.exit_price is not None:
            if self.direction == TradeDirection.LONG:
                self.pnl = (self.exit_price - self.entry_price) * self.quantity - self.commission
            else:
                self.pnl = (self.entry_price - self.exit_price) * self.quantity - self.commission
            self.pnl_pct = (self.pnl / (self.entry_price * self.quantity)) * 100

    @property
    def is_winner(self) -> bool:
        """Check if trade was profitable."""
        return self.pnl > 0

    @property
    def is_loser(self) -> bool:
        """Check if trade was unprofitable."""
        return self.pnl < 0

    def __repr__(self) -> str:
        exit_str = f"-> {self.exit_price:.2f}" if self.exit_price else "OPEN"
        return f"Trade({self.ticker} {self.direction.value} {self.entry_price:.2f} {exit_str} P&L:{self.pnl:.2f})"


@dataclass
class Position:
    """
    Current open position.

    Attributes:
        ticker: Instrument symbol
        status: Flat, long, or short
        quantity: Number of shares
        entry_price: Average entry price
        entry_time: Position entry time
        current_price: Latest price
        unrealized_pnl: Current unrealized P&L
        stop_price: Current stop loss level
        target_price: Profit target level
        trailing_stop_price: Current trailing stop level
        break_even_triggered: Whether stop moved to break-even
        bars_held: Number of bars since entry
    """
    ticker: str
    status: PositionStatus = PositionStatus.FLAT
    quantity: int = 0
    entry_price: float = 0.0
    entry_time: Optional[datetime] = None
    current_price: float = 0.0
    unrealized_pnl: float = 0.0
    stop_price: Optional[float] = None
    target_price: Optional[float] = None
    trailing_stop_price: Optional[float] = None
    break_even_triggered: bool = False
    bars_held: int = 0

    def update_price(self, price: float) -> None:
        """Update position with new price."""
        self.current_price = price
        if self.status == PositionStatus.LONG:
            self.unrealized_pnl = (price - self.entry_price) * self.quantity
        elif self.status == PositionStatus.SHORT:
            self.unrealized_pnl = (self.entry_price - price) * self.quantity

    def is_flat(self) -> bool:
        """Check if position is flat."""
        return self.status == PositionStatus.FLAT

    def __repr__(self) -> str:
        if self.is_flat():
            return f"Position({self.ticker} FLAT)"
        return f"Position({self.ticker} {self.status.value} {self.quantity} @ {self.entry_price:.2f} PnL:{self.unrealized_pnl:.2f})"


@dataclass
class TradingSession:
    """
    Single trading session (one day).

    Attributes:
        date: Session date
        ticker: Instrument symbol
        session_start: Official session start
        session_end: Official session end
        ib: Initial Balance for this session
        bars: All bars in session
        trades: Trades executed during session
    """
    date: date
    ticker: str
    session_start: datetime
    session_end: datetime
    ib: Optional[InitialBalance] = None
    bars: List[Bar] = field(default_factory=list)
    trades: List[Trade] = field(default_factory=list)

    def add_bar(self, bar: Bar) -> None:
        """Add a bar to the session."""
        self.bars.append(bar)

    def __repr__(self) -> str:
        return f"Session({self.ticker} {self.date} bars:{len(self.bars)} trades:{len(self.trades)})"


@dataclass
class BacktestResult:
    """
    Results from a backtest run.

    Attributes:
        start_date: Backtest start date
        end_date: Backtest end date
        tickers: List of tickers traded
        trades: All completed trades
        parameters: Strategy parameters used
        metrics: Performance metrics dict
        equity_curve: Equity curve as DataFrame
    """
    start_date: date
    end_date: date
    tickers: List[str]
    trades: List[Trade] = field(default_factory=list)
    parameters: Dict = field(default_factory=dict)
    metrics: Dict = field(default_factory=dict)
    equity_curve: Optional[pd.DataFrame] = None

    @property
    def total_trades(self) -> int:
        return len(self.trades)

    @property
    def winning_trades(self) -> int:
        return len([t for t in self.trades if t.is_winner])

    @property
    def losing_trades(self) -> int:
        return len([t for t in self.trades if t.is_loser])

    @property
    def win_rate(self) -> float:
        if self.total_trades == 0:
            return 0.0
        return self.winning_trades / self.total_trades * 100

    @property
    def total_pnl(self) -> float:
        return sum(t.pnl for t in self.trades)

    def __repr__(self) -> str:
        return f"BacktestResult({self.start_date} to {self.end_date} Trades:{self.total_trades} PnL:{self.total_pnl:.2f})"
